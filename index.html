<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>开源精神、极客精神-码农乐园</title>

  <!-- keywords -->
  
    <meta name="keywords" content="开源精神、极客精神">
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="欢迎进行交流纠正">
<meta name="keywords" content="开源精神、极客精神">
<meta property="og:type" content="website">
<meta property="og:title" content="码农乐园">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="码农乐园">
<meta property="og:description" content="欢迎进行交流纠正">
<meta property="og:locale" content="zh-tw">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="码农乐园">
<meta name="twitter:description" content="欢迎进行交流纠正">
  
    <link rel="alternative" href="/atom.xml" title="码农乐园" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head></html>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/1.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">陈文才</a></h1>
		</hgroup>

		
		<p class="header-subtitle">狂奔的小蜗牛</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="mail" target="_blank" href="/chen1241675760@163.com" title="mail">mail</a>
					        
								<a class="qq" target="_blank" href="/1241675760" title="qq">qq</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/JS/" style="font-size: 10px;">JS</a> <a href="/tags/面试/" style="font-size: 10px;">面试</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://wangyiye.github.io/">wangyiya</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://yuanxiaochen1.github.io">yuanxiaochen</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://jinshixi.github.io">jinshixi</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://chaiyongsheng0.github.io">chaiyongsheng0</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://ningwei7.github.io">ningwei</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">陈文才</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/1.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">陈文才</h1>
			</hgroup>
			
			<p class="header-subtitle">狂奔的小蜗牛</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="mail" target="_blank" href="/chen1241675760@163.com" title="mail">mail</a>
			        
						<a class="qq" target="_blank" href="/1241675760" title="qq">qq</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-AXIOS基础知识" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/09/16/AXIOS基础知识/" class="article-date">
  	<time datetime="2019-09-16T15:08:54.000Z" itemprop="datePublished">2019-09-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/16/AXIOS基础知识/">
        AXIOS基础知识
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="AXIOS类库的应用"><a href="#AXIOS类库的应用" class="headerlink" title="AXIOS类库的应用"></a>AXIOS类库的应用</h1><ul>
<li>一款基于Promise设计模式封装的AJAX库<h2 id="options"><a href="#options" class="headerlink" title="options"></a>options</h2></li>
<li>在使用AXIOS之前，我们一般都需要配置默认的配置项</li>
</ul>
<ol>
<li><p>baseURL：基础的URL.后期再发送请求的时候，URL请求地址最前面的公共部分就不需要再写了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.baseURL=&quot;http://127.0.0.1:5500&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>transformRequest：处理请求参数（对post系列有作用）.设置请求拦截器（只对POST系列有用）：把基于请求主体传递给服务器的内容进行拦截，把内容格式变为x-www-form-urlencoded这种格式，再传递给服务器(JQ中默认传递了)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.transformRequest = function (data) &#123;</span><br><span class="line">	if (!data) return data;</span><br><span class="line">	let str = `` ;</span><br><span class="line">	for (let key in data) &#123;</span><br><span class="line">	if (!data.hasOwnProperty(key)) break;</span><br><span class="line">		str += `&amp;$&#123;key&#125;=$&#123;data[key]&#125;`;</span><br><span class="line">	&#125;</span><br><span class="line">	return str.substring(1);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>transformResponse：处理返回的结果进行处理.设置响应拦截器：[成功状态]把从服务器获取的结果中的响应主体信息获取到即可，[失败状态]手动把错误信息抛出异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(function (response) &#123;</span><br><span class="line">			return response.data;</span><br><span class="line">		&#125;, function (error) &#123;</span><br><span class="line">			throw new Error(error);</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>headers：设置请求头:POST系列中，我们传递给服务器数据的格式一般以x-www-form-urlencoded格式为主</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.headers[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>params：get系列请求传递给服务器的内容（会把Params中的内容拼接为x-www-form-urlencode这种格式，基于url问号传参传递给服务器）(JQ中默认清缓存，axios要手动去缓存)</p>
</li>
<li><p>paramsSerializer：传递参数的序列化</p>
</li>
<li><p>timeout：超时时间</p>
</li>
<li><p>withCedentials：跨域请求中是否允许携带凭证</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.withCredentials = true;</span><br></pre></td></tr></table></figure>
</li>
<li><p>responseType：预设服务器返回结果的格式：默认是json，支持buffer、text、stream、decument</p>
</li>
<li><p>validateStatus：axios本身只有在HTTP状态码以2开头的时候才认为是成功的，其余都认为是失败状态，当然我们可以基于validateStatus这个自己来修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.validateStatus = function (status) &#123;</span><br><span class="line">			return /^(2|3)\d&#123;2&#125;$/.test(status);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="axios中的get系列方法："><a href="#axios中的get系列方法：" class="headerlink" title="axios中的get系列方法："></a>axios中的get系列方法：</h2><p>axios.get([URL],[OPTIONS]);</p>
<ul>
<li>axios.get();</li>
<li>axios.delete();</li>
<li>axios.head();<h2 id="axios中的post系列方法"><a href="#axios中的post系列方法" class="headerlink" title="axios中的post系列方法"></a>axios中的post系列方法</h2>axios.post([URL],[DATA],[OPTIONS])：DATA通过请求主传递给服务器的内容</li>
<li>axios.post();</li>
<li>axios.put();<h2 id="axios中的all方法和spread方法"><a href="#axios中的all方法和spread方法" class="headerlink" title="axios中的all方法和spread方法"></a>axios中的all方法和spread方法</h2><h3 id="axios-all-promise1-promise2"><a href="#axios-all-promise1-promise2" class="headerlink" title="axios.all([promise1, promise2]):"></a>axios.all([promise1, promise2]):</h3></li>
<li>和Promise.all()一样，都是参数是都成功后，axios.all()方法为成功，状态改变为fulfilled，执行事件池的对应发放<h3 id="axios-spread"><a href="#axios-spread" class="headerlink" title="axios.spread():"></a>axios.spread():</h3></li>
<li>把基于axios.all获取的结果一项项的单独获取到。(一般不使用)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.all([promise1, promise2]).then(axios.spread(function (val1, val2) &#123;</span><br><span class="line">			console.log(val1, val2);</span><br><span class="line">		&#125;))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="AXIOS"><a href="#AXIOS" class="headerlink" title="AXIOS"></a>AXIOS</h2><ul>
<li>执行axios.xxx()都会返回一个PROMISE实例，AJAX请求成功会把实例的状态改为fulfilled，请求失败状态改为rejected；并且获取的结果或者错误原因作为PROMISE的value<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&apos;http://127.0.0.1:5500/json/data2.json&apos;, &#123;</span><br><span class="line">			headers: &#123;</span><br><span class="line">				AAA: encodeURIComponent(&apos;珠峰哈哈哈&apos;)</span><br><span class="line">			&#125;,</span><br><span class="line">			params: &#123;</span><br><span class="line">				lx: 1,</span><br><span class="line">				from: &apos;WX&apos;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).then(result =&gt; &#123;</span><br><span class="line">			//=&gt;result：从服务器获取的结果</span><br><span class="line">			/!*</span><br><span class="line">			 * CONFIG：我们自己配置的选项信息</span><br><span class="line">			 * DATA：存储的是响应主体内容 </span><br><span class="line">			 * HEADERS：存储响应头的信息</span><br><span class="line">			 * REQUEST：AJAX实例</span><br><span class="line">			 * STATUS：响应状态码</span><br><span class="line">			 * STATUS-TEXT：状态码的描述</span><br><span class="line">			 *!/</span><br><span class="line">			return result.data;</span><br><span class="line">		&#125;).catch(reason =&gt; &#123;</span><br><span class="line">			console.log(reason);</span><br><span class="line">			throw new Error(reason);</span><br><span class="line">		&#125;).then(data =&gt; &#123;</span><br><span class="line">			//=&gt;data：从服务器获取的响应主体内容</span><br><span class="line">			console.log(data);</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Promise基础知识" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/09/16/Promise基础知识/" class="article-date">
  	<time datetime="2019-09-16T05:16:13.000Z" itemprop="datePublished">2019-09-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/16/Promise基础知识/">
        Promise基础知识
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><ul>
<li>ES6语法中新增加的内置类，用来处理JS中异步编程的。</li>
<li>Promise设计模式：基于promise对异步操作进行管理<h2 id="异步编程中的回调地狱（都是异步）"><a href="#异步编程中的回调地狱（都是异步）" class="headerlink" title="异步编程中的回调地狱（都是异步）"></a>异步编程中的回调地狱（都是异步）</h2></li>
<li>ajax的串行：请求是一个一个发送的，<strong>上一个请求完成</strong>后才进行下一个请求，每次请求成功后拿到此次请求的数据，最后一个请求成功后就拿到每一次请求的数据<br>  ajax里面再次嵌套ajax执行</li>
<li>ajax的并行：多请求可以<strong>同时发送</strong>，但是需要<strong>所有请求都成功</strong>才可以做某些事情。<h2 id="Promise基础语法"><a href="#Promise基础语法" class="headerlink" title="Promise基础语法"></a>Promise基础语法</h2><h3 id="Promise实例的三种状态PromiseStatus"><a href="#Promise实例的三种状态PromiseStatus" class="headerlink" title="Promise实例的三种状态PromiseStatus"></a>Promise实例的三种状态PromiseStatus</h3></li>
<li>pending：初始状态（new Promise（）后的状态）</li>
<li>fulfilled：成功状态（在executor函数中把resolve执行，就是告诉Promise当前异步操作的结果是成功的，将状态由pending改为fulfilled）</li>
<li>rejected：失败状态（在executor函数中把reject执行，就是告诉Promise当前异步操作的结果是失败的的，将状态由pending改为rejected）<h3 id="PromiseValue-resolve函数、reject函数中传递的参数"><a href="#PromiseValue-resolve函数、reject函数中传递的参数" class="headerlink" title="PromiseValue:resolve函数、reject函数中传递的参数"></a>PromiseValue:resolve函数、reject函数中传递的参数</h3></li>
<li>resolve函数或者reject函数执行后可以改变PromiseValue的值</li>
<li><strong>PromiseValue一旦被改变，立刻通知then方法，执行相应的方法。所以状态只可能改变一次。</strong><h3 id="执行方式：-new-Promise-executor"><a href="#执行方式：-new-Promise-executor" class="headerlink" title="执行方式： new Promise([executor])"></a>执行方式： new Promise([executor])</h3></li>
<li>执行函数作为参数函数必须传递</li>
</ul>
<ol>
<li>new Promise的时候执行executor函数，并创建一个promise实例（executor是Promise类的一个回调函数，Promise内部会把它执行）</li>
<li>Promise不仅把executor执行，还会给执行（executor）函数传递两个参数，这两个参数也是函数类型的：<ul>
<li>resolve函数：它执行代表Promise处理的异步事情是成功的，把Promise的状态改为fulfilled</li>
<li>reject函数：它执行代表Promise处理的异步事情是失败的，把Promise的状态改为rejected</li>
</ul>
</li>
<li>executor函数中放的就是当前要处理的异步操作</li>
<li>resolve函数或者reject函数执行后根据resolve函数或者reject函数的参数可以改变PromiseValue的值<h3 id="Promise-prototy实例上三个的方法"><a href="#Promise-prototy实例上三个的方法" class="headerlink" title="Promise.prototy实例上三个的方法"></a>Promise.prototy实例上三个的方法</h3><h4 id="then方法："><a href="#then方法：" class="headerlink" title="then方法："></a>then方法：</h4></li>
</ol>
<ul>
<li>向事件池中设置成功或者失败后执行的方法，两个都可以设置，也可以只设置一个</li>
<li>基于then方法，构建成功或者失败后要做的事情。当实例状态执行后，状态改变，通知then方法，传递相应的参数执行对应的方法<h4 id="catch方法："><a href="#catch方法：" class="headerlink" title="catch方法："></a>catch方法：</h4></li>
<li>向事件池中设置失败后执行的方法<h4 id="finally方法："><a href="#finally方法：" class="headerlink" title="finally方法："></a>finally方法：</h4></li>
<li>设置不论成功还是失败都会执行的方法（一般不用）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let promiseExamp = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">            //这里存放的一般是要处理的异步操作，任务成功我们执行resolve，任务失败执行reject</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                if (Math.random() &gt; 0.5) &#123;</span><br><span class="line">                    reject(&quot;shibai&quot;);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                resolve(&quot;chenggong&quot;);</span><br><span class="line">            &#125;, 1000);</span><br><span class="line">        &#125;);</span><br><span class="line">        promiseExamp.then(result =&gt; &#123;</span><br><span class="line">            //状态为fulfilled成功后执行（result：[PromiseValue]）</span><br><span class="line">            console.log(&apos;成功&apos; + result)</span><br><span class="line">        &#125;, error =&gt; &#123;</span><br><span class="line">            //状态为rejected失败后执行（result：[PromiseValue]）</span><br><span class="line">            console.log(&apos;失败&apos; + error)</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-AJAX基础操作" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/09/13/AJAX基础操作/" class="article-date">
  	<time datetime="2019-09-13T10:33:44.000Z" itemprop="datePublished">2019-09-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/13/AJAX基础操作/">
        AJAX基础操作
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><ul>
<li>ES6语法中新增加的内置类，用来处理JS中异步编程的。</li>
<li>Promise设计模式：基于promise对异步操作进行管理<h2 id="异步编程中的回调地狱（都是异步）"><a href="#异步编程中的回调地狱（都是异步）" class="headerlink" title="异步编程中的回调地狱（都是异步）"></a>异步编程中的回调地狱（都是异步）</h2></li>
<li>ajax的串行：请求是一个一个发送的，<strong>上一个请求完成</strong>后才进行下一个请求，每次请求成功后拿到此次请求的数据，最后一个请求成功后就拿到每一次请求的数据<br>  ajax里面再次嵌套ajax执行</li>
<li>ajax的并行：多请求可以<strong>同时发送</strong>，但是需要<strong>所有请求都成功</strong>才可以做某些事情。<h2 id="Promise基础语法"><a href="#Promise基础语法" class="headerlink" title="Promise基础语法"></a>Promise基础语法</h2><h3 id="执行方式：-new-Promise-executor"><a href="#执行方式：-new-Promise-executor" class="headerlink" title="执行方式： new Promise([executor])"></a>执行方式： new Promise([executor])</h3></li>
<li>执行函数作为参数函数必须传递</li>
</ul>
<ol>
<li>new Promise的时候执行executor函数，并创建一个promise实例（executor是Promise类的一个回调函数，<strong>Promise内部会把它执行</strong>）</li>
<li>Promise不仅把executor执行，还会给执行函数（executor）传递两个参数，这两个参数也是函数类型的：<ul>
<li>resolve函数：它执行代表Promise处理的异步事情是成功的，把Promise的状态改为fulfilled</li>
<li>reject函数：它执行代表Promise处理的异步事情是失败的，把Promise的状态改为rejected</li>
</ul>
</li>
<li>executor函数中放的就是当前要处理的异步操作</li>
<li>resolve函数或者reject函数执行后根据resolve函数或者reject函数的参数可以改变PromiseValue的值<br>###Promise实例上的两个属性<h4 id="PromiseValue：resolve函数、reject函数中传递的参数"><a href="#PromiseValue：resolve函数、reject函数中传递的参数" class="headerlink" title="PromiseValue：resolve函数、reject函数中传递的参数"></a>PromiseValue：resolve函数、reject函数中传递的参数</h4></li>
</ol>
<ul>
<li>resolve函数或者reject函数执行后可以改变PromiseValue的值</li>
<li><strong>PromiseValue一旦被改变，立刻通知then、catch、fianlly方法，执行相应的方法。所以状态只可能改变一次。</strong><h4 id="PromiseStatus：Promise实例的三种状态"><a href="#PromiseStatus：Promise实例的三种状态" class="headerlink" title="PromiseStatus：Promise实例的三种状态"></a>PromiseStatus：Promise实例的三种状态</h4></li>
<li>pending：初始状态（new Promise（）后的状态）</li>
<li>fulfilled：成功状态（在executor函数中把<strong>resolve</strong>执行，就是告诉Promise当前异步操作的结果是成功的，将状态由pending改为fulfilled）</li>
<li>rejected：失败状态（在executor函数中把<strong>reject</strong>执行，就是告诉Promise当前异步操作的结果是失败的的，将状态由pending改为rejected）<h3 id="Promise-prototy实例上三个的方法"><a href="#Promise-prototy实例上三个的方法" class="headerlink" title="Promise.prototy实例上三个的方法"></a>Promise.prototy实例上三个的方法</h3></li>
<li><em>Promise的链式写法*</em></li>
<li><strong>执行then()/catch()/finally()返回的结果是一个全新的Promise实例，</strong>所以可以链式写下去，下一个then中的某个方法会被执行，由上一个then中某个方法执行的结果来决定的</li>
<li>上一个then的返回值会传递给下一个then的某个方法中，作为下一个then中实例的PromiseValue值</li>
<li>如果当前PROMISE实例的状态确定后，都会到对应的THEN中找方法，如果THEN中没有对应的这个方法，则会向下顺延</li>
<li>then方法中如果<strong>返回的是一个promise实例</strong>，则当前返回实例的成功或者失败状态，影响着下一个then中哪个方法会被触发执行，如果返回的是一个非promise实例，则看当前方法执行是否报错，来决定下一个then中哪个方法执行<h4 id="then方法："><a href="#then方法：" class="headerlink" title="then方法："></a>then方法：</h4></li>
<li>向事件池中设置成功或者失败后执行的方法，两个都可以设置，也可以只设置一个</li>
<li>基于then方法，构建成功或者失败后要做的事情。当实例状态执行后，状态改变，通知then方法，传递相应的参数执行对应的方法<h4 id="catch方法："><a href="#catch方法：" class="headerlink" title="catch方法："></a>catch方法：</h4></li>
<li>向事件池中设置失败后执行的方法<h4 id="finally方法："><a href="#finally方法：" class="headerlink" title="finally方法："></a>finally方法：</h4></li>
<li>设置不论成功还是失败都会执行的方法（一般不用）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let promiseExamp = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">            //这里存放的一般是要处理的异步操作，任务成功我们执行resolve，任务失败执行reject</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                if (Math.random() &gt; 0.5) &#123;</span><br><span class="line">                    reject(&quot;shibai&quot;);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                resolve(&quot;chenggong&quot;);</span><br><span class="line">            &#125;, 1000);</span><br><span class="line">        &#125;);</span><br><span class="line">        promiseExamp.then(result =&gt; &#123;</span><br><span class="line">            //状态为fulfilled成功后执行（result：[PromiseValue]）</span><br><span class="line">            console.log(&apos;成功&apos; + result)</span><br><span class="line">        &#125;, error =&gt; &#123;</span><br><span class="line">            //状态为rejected失败后执行（result：[PromiseValue]）</span><br><span class="line">            console.log(&apos;失败&apos; + error)</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Promise的两个方法："><a href="#Promise的两个方法：" class="headerlink" title="Promise的两个方法："></a>Promise的两个方法：</h3><h4 id="Promise-all-promise1-promise2-…"><a href="#Promise-all-promise1-promise2-…" class="headerlink" title="Promise.all([promise1,promise2,…]):"></a>Promise.all([promise1,promise2,…]):</h4><ul>
<li>ALL中存放的是多个PROMISE实例（每一个实例管理着一个异步操作），执行ALL方法返回的结果是一个新的PROMISE实例”PROA”</li>
<li>当<strong>所有PROMISE实例的状态都为Fulfilled</strong>的时候（成功），让PROA的状态也变为Fulfilled，并且把所有PROMISE成功获取的结果，存储为成为一个数组（顺序和最开始编写的顺序一致）“result=[result1,result2,…]”，让PROA这个数组的VALUE值等于这个数组</li>
<li>都成功（PROA状态是FUFILLED）才会通知THEN中第一个方法执行，只要有一个失败（PROA状态是REJECTED），就会通知THEN中第二个方法或者CATCH中的方法执行<h4 id="Promise-race-ajax1-ajax3-ajax2"><a href="#Promise-race-ajax1-ajax3-ajax2" class="headerlink" title="Promise.race([ajax1(), ajax3(), ajax2()]):"></a>Promise.race([ajax1(), ajax3(), ajax2()]):</h4></li>
<li>看哪一个PROMISE状态最先处理完（成功或者失败），以最先处理完的为主</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-AJAX介绍" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/09/13/AJAX介绍/" class="article-date">
  	<time datetime="2019-09-13T09:13:43.000Z" itemprop="datePublished">2019-09-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/13/AJAX介绍/">
        AJAX介绍
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="AJAX（客户端和服务器之间的数据交互）"><a href="#AJAX（客户端和服务器之间的数据交互）" class="headerlink" title="AJAX（客户端和服务器之间的数据交互）"></a>AJAX（客户端和服务器之间的数据交互）</h1><h2 id="AJAX基础知识"><a href="#AJAX基础知识" class="headerlink" title="AJAX基础知识"></a>AJAX基础知识</h2><h3 id="AJAX介绍"><a href="#AJAX介绍" class="headerlink" title="AJAX介绍"></a>AJAX介绍</h3><pre><code>1. ajax：async JavaScript and xml（异步的js和xml）
2. 此处的异步指的是局部刷新（对应的是全局刷新）</code></pre><h3 id="服务器渲染"><a href="#服务器渲染" class="headerlink" title="服务器渲染"></a>服务器渲染</h3><pre><code>1. 服务器接收到请求后，找到指定的页面，找到页面源代码
2. 根据需求从数据库中获取到需要动态展示的数据
3. 把页面和数据混合在一起进行渲染，生成有结构样式和数据的完整页面
4. 把渲染的完整页面返回给客户端</code></pre><p><strong>服务器渲染特点：</strong><br>    1. 我们看到的内容都是在服务器端渲染的，客户端只是将渲染后的完整页面展示出来。但是<strong>服务器渲染只能全局刷新</strong><br>    2. 全局刷新性能体验差，服务器压力大<br>    3. 当服务器性很高时，页面呈现速度快，异步到位<br>    4. 由于内容在服务器端已经渲染好了，所以在页面源代码中都可以看到内容，有利于SEO搜索优化<br>    5. 不利于团队协作开发</p>
<h3 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h3><pre><code>1. 服务器接收请求后，把需要的页面代码返回给客户端
2. 客户端拿到代码进行渲染，此时只有结构和样式，没有数据
3. 客户端向服务器发送请求，请求数据
4. 服务器获得请求信息，把数据返回给客户端
5. 客户端获取数据并展示在页面上（**可以实现局部刷新**）</code></pre><p><strong>客户端渲染特点：</strong><br>    1. 可以实现页面的局部刷新。减少服务器的压力<br>    2. 可以实现数据的分批加载。先请求结构和样式，不请求数据，滚动到当前页再发送ajax请求，渲染数据。<br>    3. 由客户端渲染的内容不会出现在页面的源代码中，不利于SEO优化。</p>
<p>###当代项目开发的整个架构模型<br>    1. 纯服务器渲染（需要做SEO优化）<br>    2. 混编模式：部分是服务器渲染，部分是客户端渲染的<br>        * 骨架屏：首屏内容是服务器渲染（目的是首屏加载速度变快，对服务器压力大），其余屏内容都是客户端基于ajax获取渲染的，对于表单提交等数据操作都是客户端基于ajax操作<br>    3. 完全客户端和服务器分离开发（目前常用，完全前后端分离）<br>        * vue<br>        * react<br>    4. 把vue、react在服务器端基于node来渲染(服务器渲染)</p>
<h2 id="XML介绍"><a href="#XML介绍" class="headerlink" title="XML介绍"></a>XML介绍</h2><p><strong>xml：</strong>可扩展标记语言。可扩展标记语言仅仅是存储数据，用自己定义的标签来存储数据。可以清晰的展示对应的数据和结构层级。<br><strong>JSON：</strong>现在开发使用的存储数据的语言。比xml更清晰的展示数据结构，而且同样的数据存储，json更加轻量，操作更加简单。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-性能优化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/09/13/性能优化/" class="article-date">
  	<time datetime="2019-09-13T06:03:08.000Z" itemprop="datePublished">2019-09-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/13/性能优化/">
        性能优化
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h1><h2 id="1-减少HTTP请求次数和传输报文的大小"><a href="#1-减少HTTP请求次数和传输报文的大小" class="headerlink" title="1. 减少HTTP请求次数和传输报文的大小"></a>1. 减少HTTP请求次数和传输报文的大小</h2><ol>
<li><strong>文件合并压缩</strong></li>
<li>雪碧图 css sprite</li>
<li>图片base64（用base码代表图片，减少HTTP请求，增加浏览器渲染速度，所以真实项目中，尤其是移动端，如果图片加载缓慢，可能base64就好了；但是，base64不利于维护和开发，所以少使用；）</li>
<li>尽量使用字体图标（icon font）或者SVG等矢量图<br> <strong>优势：</strong><ol>
<li>减少HTTP请求次数和传输报文的大小</li>
<li>渲染更快：他们都是基于代码渲染的，而对于位图（.gif/jpg/gif）是需要先把图片编码在渲染</li>
<li>不容易失帧变形</li>
</ol>
</li>
<li><strong>图片懒加载（延迟加载技术）（数据懒加载，不要一次加载太多数据）</strong><br> <strong>优势：</strong><ol>
<li>第一次加载不去加载真实的图片，提高第一次渲染页面的速度</li>
<li>当页面加载完，把出现在用户视野中的图片加载，不出现的不加载（节约流量，也减少了对服务器的压力）</li>
</ol>
</li>
<li>音视频取消预加载</li>
<li>在客户端和服务器端进行信息交互的时候，对于多项数据我们尽可能基于JSON格式来进行传送（JSON格式的数据处理方便，资源偏小），XML格式比JSON格式要大（还可以基于二进制或者文件流传输）</li>
<li>开启服务器端的gzip压缩。把页面中的CSS、JS、图片等文件进行合并并压缩<br> 合并：争取css和js都只导入一个（webpack可以实现自动合并压缩）<br> 压缩：基于webpack可以压缩，对于图片自己可以先压缩，还可以使用服务器的GZIP压缩</li>
<li>图片地图：对于多次调取使用的图片（尤其是背景图），我们尽可能把它提取成为公共的样式，需要的时候加上样式就可以了，不需要每次都舍此background。<h2 id="2-设置各种缓存、预处理和长连接机制"><a href="#2-设置各种缓存、预处理和长连接机制" class="headerlink" title="2. 设置各种缓存、预处理和长连接机制"></a>2. 设置各种缓存、预处理和长连接机制</h2><h3 id="网络缓存优化"><a href="#网络缓存优化" class="headerlink" title="网络缓存优化"></a>网络缓存优化</h3></li>
<li>DNS缓存或者预处理（DNS PREFETCH），减少DNS的查找</li>
<li>把不经常更改的静态资源做缓存处理。强缓存(Expires HTTP) 和 协商缓存（304）</li>
<li>建立connection：keep-alive ，TCP长连接<h3 id="本地缓存优化"><a href="#本地缓存优化" class="headerlink" title="本地缓存优化"></a>本地缓存优化</h3></li>
<li>设置本地的离线存储（manifest）或者把一些不经常更改的数据做成本地临时存储<br>###其他优化</li>
<li>地域分布式服务器CDN。还可以加服务器（都需要很多钱）</li>
<li>使用HTTP2版本协议（现在一般都是HTTP1.1）<br> HTTP2版本协议支持多条TCP通道共存=》管道化连接<h2 id="3-代码方面的性能优化"><a href="#3-代码方面的性能优化" class="headerlink" title="3. 代码方面的性能优化"></a>3. 代码方面的性能优化</h2></li>
<li>减少DOM的重绘和回流（减少直接对DOM操作），当代项目一般都是基于mvvm、mvc数据驱动视图渲染的，性能要好。</li>
<li>在JS中尽量减少闭包的使用<br> <strong>原理：</strong>过多使用闭包会产生不销毁的内存，处理不好会导致“栈溢出”<br> 栈溢出实例：<ol>
<li>死递归（可以用定时器方式解决）</li>
<li>相互引用，形成嵌套式内存</li>
</ol>
</li>
<li>在JS中避免“嵌套循环（嵌套循环会成倍增加循环次数）”和“死循环”</li>
<li>尽可能使用事件委托。（也是减少dom操作）</li>
<li>手动回收堆栈内存（赋值为null）</li>
<li>尽可能减少选择器的层级。（CSS选择器解析规则是从右向左解析）</li>
<li>避免使用iframe（因为iframe会嵌入其他页面，这样父页面渲染的时候还会把子页面渲染了，渲染进度会变慢）</li>
<li>尽可能实现JS的封装（低耦合高内聚），减少页面中的冗余代码。</li>
<li><ol>
<li>尽量减少对于filter滤镜属性的使用（耗性能）。</li>
<li>避免使用with语句（性能特别差）。</li>
<li>尽量减少CSS表达式的使用(expression)（性能特别差，和with一样）</li>
</ol>
</li>
<li>在项目中尽可能使用异步编程来模拟出多线程的效果，避免主线程阻塞。（在CSS导入的时候尽量减少使用@import导入式）</li>
<li>对于动画来说，能使用css解决的不适用js，（能使用transform处理的，不用传统的css样式，应为transform开启了性能加速，不会引发回流，再或者使用定位元素，脱离文档流。使用window.requestAnimationFrame（JS中的帧动画）代替传统的定时器动画）<br>window.requestAnimationFrame：当页面处于休眠无访问状态，动画会自己暂停，知道恢复访问才开始，而定时器是不论什么状态，只要页面不关闭，动画一直运行</li>
<li>减少递归的使用，避免死递归，避免由于递归导致的栈内存嵌套</li>
<li>减少使用eval（主要原因是防止压缩代码时候，由于符号书写不规范，导致代码混乱）</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-前端性能优化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/09/11/前端性能优化/" class="article-date">
  	<time datetime="2019-09-11T12:26:57.000Z" itemprop="datePublished">2019-09-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/11/前端性能优化/">
        前端性能优化
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>本篇文章缘起一次偶然的面试问答所引申出的思考整理，着笔于浏览器渲染的角度，探讨前端性能优化的思路和实践建议，当然，浏览器渲染是一个复杂的过程，本文笔者将围绕重排和重绘两个关键词开始行文。</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>文章大致行文思路如下：</p>
<ul>
<li>URL从输入到页面展示的过程</li>
<li>DOM和JavaScript的关系</li>
<li>为什么操作DOM会很“慢”</li>
<li>浏览器解析HTML的过程</li>
<li>重排</li>
<li>重绘</li>
<li>优化方案<h2 id="URL从输入到页面展示的过程"><a href="#URL从输入到页面展示的过程" class="headerlink" title="URL从输入到页面展示的过程"></a>URL从输入到页面展示的过程</h2>在探讨浏览器解析html之前，先了解url从输入到最后页面渲染的过程是一个很有必要的步骤，它可以帮助我们把握整体流程，让我们在了解HTML解析细节之前知道它处于整个请求周期中的哪一阶段，这对我们构建完善知识图谱很有帮助。</li>
<li>首先，我们假设输入的url的请求为最简单的Http请求，以GET请求为例，大致分以下几个步骤：</li>
<li><ol>
<li>用户在浏览器的地址栏输入访问的URL地址。浏览器会先根据这个URL查看浏览器缓存-系统缓存-路由器缓存，若缓存中有，直接跳到第6步操作，若没有，则按照下面的步骤进行操作。</li>
</ol>
</li>
<li><ol start="2">
<li>浏览器根据输入的URL地址解析出主机名。</li>
</ol>
</li>
<li><ol start="3">
<li>浏览器将主机名转换成服务器ip地址。浏览器先查找本地DNS缓存列表，看缓存里面是否存在这个ip,如果有则进入第4步，如果缓存中不存在这个ip地址，就再向浏览器默认的DNS服务器发送查询请求，同时缓存当前这个ip到DNS缓存列表中。更详细步骤参考DNS查找域名的过程。</li>
</ol>
</li>
<li><ol start="4">
<li>拿到ip地址后，浏览器再从URL中解析出端口号。</li>
</ol>
</li>
<li><ol start="5">
<li>拿到ip和端口后，浏览器会建立一条与目标Web服务器的TCP连接，也就是传说中的三次握手。传送门：完整的tcp链接。</li>
</ol>
</li>
<li><ol start="6">
<li>浏览器向服务器发送一条HTTP请求报文。</li>
</ol>
</li>
<li><ol start="7">
<li>服务器向浏览器返回一条HTTP响应报文。</li>
</ol>
</li>
<li><ol start="8">
<li>关闭连接 浏览器解析文档。</li>
</ol>
</li>
<li><ol start="9">
<li>如果文档中有资源则重复6、7、8动作，直至资源全部加载完毕。</li>
</ol>
</li>
<li>以上步骤简述了浏览器从输入url到最后页面呈现的大致过程，但这并不很具体，比如浏览器请求报文类型是什么，会遇到哪些错误场景、浏览器又是如何解析响应报文等等都没具体描述。<br>实际上在http请求方式不同、有无代理、有无负载均衡等不同场景下访问服务器的细节流程也会有一些差别，但这并不影响我们对整个访问环节的理解，有兴趣的同学可网上自行详细了解，在此不做详述。<h2 id="DOM和JavaScript的关系"><a href="#DOM和JavaScript的关系" class="headerlink" title="DOM和JavaScript的关系"></a>DOM和JavaScript的关系</h2></li>
<li>文档对象模型（DOM）是一个独立于语言，用于操作XML和HTML文档的API,在web端，我们常用来操作HTML，但其实DOM也是可以操作XML文档的。</li>
<li>我们现在知道，DOM是一个独立于语言的API，换句话说，DOM是一个与语言无关的API，别的语言也可以实现操作DOM的具体api，但是它在浏览器中是用JavaScript来实现的，也因此，DOM是现在JavaScript编码中很重要的一部分，因为JavaScript很多时候都在操作底层文档。<h2 id="为什么操作DOM会很慢"><a href="#为什么操作DOM会很慢" class="headerlink" title="为什么操作DOM会很慢"></a>为什么操作DOM会很慢</h2></li>
<li>虽然DOM是由JavaScript实现的，但是在浏览器中都是把DOM和JavaScript分开来实现的，比如IE中，JavaScript的实现名为JScript，放在jscript.dll文件中，而DOM则放在另一个叫做mshtml.dll的库中。在Safari中，DOM和渲染是使用Webkit中的WebCore实现，而JavaScript是由独立的JavaScriptCore引擎实现，同样在Chrome中，同样是使用WebCore来实现渲染，而JavaScript引擎则是他们自己研发的V8引擎。</li>
<li>由于DOM和JavaScript是被分开独立实现的，因此，每一次在通过js操作DOM的时候，就需要先去连接js和DOM，我们可以这样理解：把DOM和JavaScript比作两个岛，他们之间通过一个收费的桥连接着，每一次访问DOM的时候，就需要经过这座桥，并且给“过路费”，访问的次数越多，路费就会越高，并且访问到DOM后，操作具体的DOM还需要给“操作费”，由于浏览器访问DOM的操作很多，因此，“路费”和“操作费”自然会增加，这就是为什么操作DOM会很慢的原因<h2 id="浏览器渲染HTML的步骤"><a href="#浏览器渲染HTML的步骤" class="headerlink" title="浏览器渲染HTML的步骤"></a>浏览器渲染HTML的步骤</h2></li>
<li>HTML渲染大致分为如下几步：</li>
<li><ol>
<li>HTML被HTML解析器解析成DOM Tree, css则被css解析器解析成CSSOM Tree。</li>
</ol>
</li>
<li><ol start="2">
<li>DOM Tree和CSSOM Tree解析完成后，被附加到一起，形成渲染树（Render Tree）。</li>
</ol>
</li>
<li><ol start="3">
<li>节点信息计算(重排)，这个过程被叫做Layout(Webkit)或者Reflow(Mozilla)。即根据渲染树计算每个节点的几何信息。</li>
</ol>
</li>
<li><ol start="4">
<li>渲染绘制(重绘)，这个过程被叫做(Painting 或者 Repaint)。即根据计算好的信息绘制整个页面。</li>
</ol>
</li>
<li>以上4步简述浏览器的一次渲染过程，理论上，每一次的dom更改或者css几何属性更改，都会引起一次浏览器的重排/重绘过程，而如果是css的非几何属性更改，则只会引起重绘过程。所以说重排一定会引起重绘，而重绘不一定会引起重排。<h2 id="重排（Relayout-Reflow）"><a href="#重排（Relayout-Reflow）" class="headerlink" title="重排（Relayout/Reflow）"></a>重排（Relayout/Reflow）</h2></li>
<li>在弄明白什么是重排之前，我们要知道：浏览器渲染页面默认采用的是流式布局模型（Flow Based Layout），这一点很重要。</li>
<li>所谓重排，实际上是根据渲染树中每个渲染对象的信息，计算出各自渲染对象的几何信息（DOM对象的位置和尺寸大小），并将其安置在界面中的正确位置。</li>
<li>由于浏览器渲染界面是基于流式布局模型的，也就是某一个DOM节点信息更改了，就需要对DOM结构进行重新计算，重新布局界面，再次引发回流，只是这个结构更改程度会决定周边DOM更改范围，即全局范围和局部范围，全局范围就是从根节点html开始对整个渲染树进行重新布局，例如当我们改变了窗口尺寸或方向或者是修改了根元素的尺寸或者字体大小等；而局部布局可以是对渲染树的某部分或某一个渲染对象进行重新布局。<h2 id="在此，总结会引起重排的操作有："><a href="#在此，总结会引起重排的操作有：" class="headerlink" title="在此，总结会引起重排的操作有："></a>在此，总结会引起重排的操作有：</h2></li>
<li><ol>
<li>页面首次渲染。</li>
</ol>
</li>
<li><ol start="2">
<li>浏览器窗口大小发生改变。</li>
</ol>
</li>
<li><ol start="3">
<li>元素尺寸或位置发生改变。</li>
</ol>
</li>
<li><ol start="4">
<li>元素内容变化（文字数量或图片大小等等）。</li>
</ol>
</li>
<li><ol start="5">
<li>元素字体大小变化。</li>
</ol>
</li>
<li><ol start="6">
<li>添加或者删除可见的DOM元素。</li>
</ol>
</li>
<li><ol start="7">
<li>激活CSS伪类（例如：:hover）。</li>
</ol>
</li>
<li><ol start="8">
<li>设置style属性</li>
</ol>
</li>
<li><ol start="9">
<li>查询某些属性或调用某些方法。<h2 id="常见引起重排属性和方法"><a href="#常见引起重排属性和方法" class="headerlink" title="常见引起重排属性和方法"></a>常见引起重排属性和方法</h2>width height margin padding<br>display border position overflow<br>clientWidth clientHeight clientTop clientLeft<br>offsetWidth offsetHeight offsetTop offsetLeft<br>scrollWidth scrollHeight scrollTop scrollLeft<br>scrollIntoView() scrollTo() getComputedStyle()<br>getBoundingClientRect() scrollIntoViewIfNeeded()</li>
</ol>
</li>
<li>重排也叫回流，实际上，reflow的字面意思也是回流，之所以有的叫做重排，也许是因为重排更好理解，更符合中国人的思维。标准文档之所以叫做回流（Reflow）,是因为浏览器渲染是基于“流式布局”的模型，流实际就使我们常说的文档流，当dom或者css几何属性发生改变的时候，文档流会受到波动联动的去更改，流就好比一条河里的水，回流就好比向河里扔了一块石头，激起涟漪，然后引起周边水流受到波及，所以叫做回流，这样理解似乎更标准更规范，不过叫什么并不重要，重要的是我们真正理解了这个过程便好。<h2 id="重绘（Repainting）"><a href="#重绘（Repainting）" class="headerlink" title="重绘（Repainting）"></a>重绘（Repainting）</h2></li>
<li>相比重排，重绘就简单多了，所谓重绘，就是当页面中元素样式的改变并不影响它在文档流中的位置时，例如更改了字体颜色,浏览器会将新样式赋予给元素并重新绘制的过程称。</li>
<li>常见引起浏览器绘制过程的属性包含：<br>color border-style visibility background<br>text-decoration background-image background-position background-repeat<br>outline-color outline outline-style border-radius<br>outline-width box-shadow background-size<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2></li>
<li>我们知道操作DOM是一个高成本的操作，不仅是因为本身js与DOM的链接访问，还包括操作DOM后会引起一连串的连锁反应（重排），因此，从性能优化角度，我们可以从以下几个方面着手：</li>
<li><ol>
<li>减少DOM操作</li>
</ol>
</li>
<li><ul>
<li>最小化DOM访问次数，尽量缓存访问DOM的样式信息，避免过度触发回流。</li>
</ul>
</li>
<li><ul>
<li>如果在一个局部方法中需要多次访问同一个dom，则先暂存它的引用。</li>
</ul>
</li>
<li><ol start="2">
<li>采用更优的API替代消费高的api，转换优化消费高的集合</li>
</ol>
</li>
<li><ul>
<li>用querySelectorAll()替代getElementByXX()。</li>
</ul>
</li>
<li><ul>
<li>开启动画的GPU加速，把渲染计算交给GPU。</li>
</ul>
</li>
<li><ul>
<li>少用HTML集合（类数组）来遍历，因为集合遍历比真数组遍历耗费更高。</li>
</ul>
</li>
<li><ul>
<li>用事件委托来减少事件处理器的数量。</li>
</ul>
</li>
<li><ol start="3">
<li>减少重排</li>
</ol>
</li>
<li><ul>
<li>避免设置大量的style属性，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow，所以最好是使用class属性</li>
</ul>
</li>
<li><ul>
<li>实现元素的动画，它的position属性，最好是设为absoulte或fixed，这样不会影响其他元素的布局</li>
</ul>
</li>
<li><ul>
<li>动画实现的速度的选择。比如实现一个动画，以1个像素为单位移动这样最平滑，但是reflow就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多。</li>
</ul>
</li>
<li><ul>
<li>不要使用table布局，因为table中某个元素旦触发了reflow，那么整个table的元素都会触发reflow。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围</li>
</ul>
</li>
<li><ol start="4">
<li>css及动画处理</li>
</ol>
</li>
<li><ul>
<li>少用css表达式</li>
</ul>
</li>
<li><ul>
<li>减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画；</li>
</ul>
</li>
<li><ul>
<li>动画尽量使用在绝对定位或固定定位的元素上；</li>
</ul>
</li>
<li><ul>
<li>隐藏在屏幕外，或在页面滚动时，尽量停止动画；<h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2></li>
</ul>
</li>
<li>本篇文章主要抓取url从输入到最后渲染成界面这一流程中的浏览器解析渲染HTML这一步骤来探讨前端优化的思路和原因，核心思想基于重排和重绘的关系来展开讨论，主题大致有如下几点：</li>
<li>url从输入到最后渲染的大致环节。</li>
<li>重排一定会重绘，重绘不一定有重排。</li>
<li>Js操作DOM是一个高消费过程。</li>
<li>会引起重排/重绘的属性和方法列举</li>
<li>优化思路（减少dom操作、替换高性能api、暂存引用、减少重排、开启硬件加速等）。<br>感谢这个时代，让我们可以站在巨人的肩膀上，窥探程序世界的宏伟壮观，我愿以一颗赤子心，踏遍程序世界的千山万水！愿每一个行走在程序世界的同仁，都活成心中想要的样子，加油。<br>来源：慕课网<br>本文原创发布于慕课网 ，转载请注明出处，谢谢合作</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-客户端和服务器端-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/09/11/客户端和服务器端-1/" class="article-date">
  	<time datetime="2019-09-11T03:46:21.000Z" itemprop="datePublished">2019-09-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/11/客户端和服务器端-1/">
        客户端和服务器端
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="客户端和服务器端"><a href="#客户端和服务器端" class="headerlink" title="客户端和服务器端"></a>客户端和服务器端</h1><h2 id="客户端和服务器端的理解"><a href="#客户端和服务器端的理解" class="headerlink" title="客户端和服务器端的理解"></a>客户端和服务器端的理解</h2><ul>
<li>客户端：可以向服务器发请求，并接收返回的内容进行处理</li>
<li>服务器端：能够接收客户端请求，并且把相关的资源<h2 id="客户端和服务器端之间的交互模型"><a href="#客户端和服务器端之间的交互模型" class="headerlink" title="客户端和服务器端之间的交互模型"></a>客户端和服务器端之间的交互模型</h2><h3 id="请求阶段request："><a href="#请求阶段request：" class="headerlink" title="请求阶段request："></a>请求阶段request：</h3></li>
</ul>
<ol>
<li>浏览器进行 URL 地址解析</li>
<li>DNS（域名服务器）进行域名解析，确定要连接哪台服务器</li>
<li>和服务器建立TCP连接</li>
<li>把客户端信息传递给服务器（发送HTTP请求）</li>
<li>服务器得到并处理请求（HTTP响应内容） <h3 id="响应阶段response："><a href="#响应阶段response：" class="headerlink" title="响应阶段response："></a>响应阶段response：</h3></li>
<li>客户端渲染服务器返回的内容</li>
<li>断开和服务器的TCP连接<h3 id="地址解析URL-URI-URN"><a href="#地址解析URL-URI-URN" class="headerlink" title="地址解析URL/URI/URN"></a>地址解析URL/URI/URN</h3></li>
</ol>
<ul>
<li>URL：统一资源定位器，根据这个地址能够找到对应的资源</li>
<li>URN：统一资源名称，一般指国际上通用的一些名字，例如国际统一发版的编号</li>
<li>URI：统一资源标识符，URL和URN都是URI的子集。<h3 id="一个完整的URL所包含的内容"><a href="#一个完整的URL所包含的内容" class="headerlink" title="一个完整的URL所包含的内容"></a>一个完整的URL所包含的内容</h3></li>
<li><a href="http://www.zhufengpeixun.cn:80/stu/index.html?form=wx&amp;lx=1#zhufeng" target="_blank" rel="noopener">http://www.zhufengpeixun.cn:80/stu/index.html?form=wx&amp;lx=1#zhufeng</a></li>
</ul>
<p><strong>协议(http://)  :传输协议就是能够把客户端和服务器端通信的信息进行传输的工具。（类似于快递小哥）</strong></p>
<ul>
<li>常见的传输协议：</li>
</ul>
<ol>
<li>http 超文本传输协议。除了传输文本，还可以传输媒体资源文件（或者流文件）及XML格式数据</li>
<li>https 更加安全的http，一般涉及支付的网站都要采用https协议（s:ssl加密传输）</li>
<li>ftp 文件传输协议。FileZilla:ftp上传工具，通过这个工具可以把本地文件上传服务器上。（一般应用于把本地资源上传到服务器端）</li>
</ol>
<p><strong>域名(<a href="http://www.zhufengpeixun.cn" target="_blank" rel="noopener">www.zhufengpeixun.cn</a>)  ：一个让用户方便记忆的名字（不通过域名，通过外网IP也可以访问服务器）</strong></p>
<ul>
<li>顶级域名  qq.com</li>
<li>一级域名 <a href="http://www.qq.com" target="_blank" rel="noopener">www.qq.com</a></li>
<li>二级域名 sports.qq.com</li>
<li>三级域名 kbs.sports.qq.com</li>
<li>.com  国际域名</li>
<li>.cn     中文域名</li>
<li>.com.cn  怎么用都行</li>
<li>.edu  教育单位</li>
<li>.gov  政府单位</li>
<li>.io   博客</li>
<li>.org  官方组织</li>
<li>.net   系统类网站</li>
</ul>
<p><strong>端口号(:80)   范围：0~65535  用端口号来区分同一台服务器上的不同项目</strong></p>
<ul>
<li>http默认端口号：80</li>
<li>https默认端口号：443</li>
<li>ftp默认端口号：21</li>
<li>如果项目采用的就是默认端口号，我们在书写地址的时候不用加端口号，浏览器在发送请求的时候会帮我们默认加上</li>
</ul>
<p><strong>请求资源路径名称(/stu/index.html)</strong></p>
<ul>
<li>默认的路径或者名称（不指定资源名，服务器会找到默认的资源，一般默认的资源名是defaule.html 可以自己配置）</li>
<li>注意伪URL的处理</li>
<li>URL重写技术是为了增加SEO搜索引擎优化的，动态的网址一般不能被搜索引擎收录，所以我们要把动态网址静态化，此时需要的是重写URL</li>
<li>服务器接收到请求后</li>
</ul>
<ol>
<li>根据端口号找到对应的项目</li>
<li>根据请求资源的路径名称找到对应的资源</li>
<li>将找到的资源传递给客户端</li>
</ol>
<p><strong>问号传参信息(?form=wx&amp;lx=1)</strong></p>
<ul>
<li>客户端把信息传递给服务器的方式</li>
<li>URL地址问号传参</li>
<li>请求报文传输（请求头和请求主体）</li>
<li>也可以不同页面之间的信息交互，例如从列表到详情</li>
</ul>
<p><strong>HASH值(#zhufeng)</strong></p>
<ul>
<li>也能充当信息传输的方式</li>
<li>锚点定位</li>
<li>基于HASH实现路由管控（不同的HASH值，代表不同的组件和模块）</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-less" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/09/10/less/" class="article-date">
  	<time datetime="2019-09-10T11:16:39.000Z" itemprop="datePublished">2019-09-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/10/less/">
        less介绍
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="less"><a href="#less" class="headerlink" title="less"></a>less</h1><blockquote>
<p><a href="http://lesscss.cn/" target="_blank" rel="noopener">http://lesscss.cn/</a><br>Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。<br>预期类似的预编译器（语言）还有：sass/stylus等；所谓的预编译，就是把css这种标记语言，按照面向对象（编程语言）的方式进行编写，但是这种写法浏览器不能直接识别，需要我们把其再编译为正常的css代码才可以</p>
</blockquote>
<h2 id="less使用方式"><a href="#less使用方式" class="headerlink" title="less使用方式"></a>less使用方式</h2><blockquote>
<p> less的编译常用的分为两种</p>
</blockquote>
<h3 id="1-开发环境下（开发项目的时候）"><a href="#1-开发环境下（开发项目的时候）" class="headerlink" title="1.开发环境下（开发项目的时候）"></a>1.开发环境下（开发项目的时候）</h3><blockquote>
<p>我们基于less-2.5.3.min.js进行编译：基于link把less文件导入，但是rel的值必须是stylesheet/less，这样导入的js会找到这些less文件，把less编译为css即可</p>
</blockquote>
<p>###2.生产环境中（项目部署上线的时候）</p>
<blockquote>
<p>我们需要把less编译为css，然后让页面中导入的都是编译后的css，需要基于node环境，并且基于less模块进行编译（命令操作方式）<br> 安装node（安装npm）<br>          $ npm install less -g<br>找到对应的less文件目录，在目录中：$ lessc xxx.less xxx.css  -x(设置-x是为了把代码压缩))</p>
</blockquote>
<p>###less注意事项</p>
<blockquote>
<p>我们基于@import最好导入的是LESS文件（只有这样最后才能编译到一起；设置reference是只导入进来调取使用，编译的时候不进行编译；</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import (reference) &apos;./common.less&apos;;</span><br></pre></td></tr></table></figure>

<h3 id="less-1"><a href="#less-1" class="headerlink" title="less"></a>less</h3><blockquote>
<ol>
<li>嵌套（减少前缀） </li>
<li>每一个大括号都是一个私有的作用域，在里面用到的变量，先看是否为私有的（是否在当前作用域中声明过和形参变量），不是私有的，找上级作用域中的 =&gt;”类似于JS作用域链这套机制” </li>
<li>unit(变量名，变更单位)：less中内置的函数，用来设置或者去除单位的（有单位就是去除单位，没单位就是加上单位）</li>
<li>一般变量设置时都不加单位，什么时候用再加单位</li>
<li>&amp;嵌套中的连接符,让后面的选择器紧挨着父选择器 .box1&gt;img</li>
<li>@W-20这样被理解为是一个变量名（变量名可以包含-）</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.box1 &#123;</span><br><span class="line">	@A1: lightgreen;</span><br><span class="line">	@W: 200;</span><br><span class="line">	@H: 200px;</span><br><span class="line">	.func_center(@W, unit(@H, px));</span><br><span class="line">	box-sizing: border-box;</span><br><span class="line">	width: unit(@W, px);</span><br><span class="line">	height: @H;</span><br><span class="line">	border: 5px solid @A1;</span><br><span class="line">	//.box1 img</span><br><span class="line">	img &#123;</span><br><span class="line">		//@W-20这样被理解为是一个变量名（变量名可以包含-）</span><br><span class="line">		width: unit((@W)-20, px);</span><br><span class="line">		height: unit(unit(@H, px)-20, px);</span><br><span class="line">	&#125;</span><br><span class="line">	//&amp;嵌套中的连接符,让后面的选择器紧挨着父选择器 .box1&gt;img</span><br><span class="line">	// &amp;&gt;img &#123;</span><br><span class="line">	// 	transform: skew(45deg);</span><br><span class="line">	// &#125;</span><br><span class="line">	//.box1:hover</span><br><span class="line">	&amp;:hover &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="less中的三种函数"><a href="#less中的三种函数" class="headerlink" title="less中的三种函数"></a>less中的三种函数</h3><blockquote>
<p> 1.每一个样式类都能被充当一个函数，直接在其它的作用域中调取执行（执行特点：不需要传参，可以不加小括号） =&gt;这种函数的调用是把原有的代码都原封不动的拿过来一份一模一样的（包括其所有的后代样式）<br> 2.带参数的函数（创建函数带着小括号），也是直接点的方式调用，但是编译成为css的时候，函数不会编译，但是函数执行出来的代码会放到每一个调取函数的选择器中，<strong>存在argument</strong><br>3.less中的内置函数</p>
<blockquote>
<p>  unit(变量名，变量单位)<br> darken(颜色变量名，变深百分比)<br> lighten(颜色变量名，变浅百分比)</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.box2 &#123;</span><br><span class="line"> 	.box1;</span><br><span class="line"> &#125;</span><br><span class="line"> .box2 &#123;</span><br><span class="line"> 	&amp;:extend(.box1);</span><br><span class="line"> &#125;</span><br><span class="line"> .box2:extend(.box1) &#123;&#125;</span><br><span class="line"> .link &#123;</span><br><span class="line">	@BG: lightblue;</span><br><span class="line">	margin: 20px;</span><br><span class="line">	width: 100px;</span><br><span class="line">	height: 35px;</span><br><span class="line">	border: 1px solid #AAA;</span><br><span class="line">	background: @BG;</span><br><span class="line">	&amp;:hover &#123;</span><br><span class="line">		background: lighten(@BG, 10%);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="less中的继承extend"><a href="#less中的继承extend" class="headerlink" title="less中的继承extend"></a>less中的继承extend</h3><blockquote>
<p>1.基于继承也能实现样式的公用（原理：两个样式类公用同一套代码，但是后代样式不能被继承）</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/09/10/hello-world/" class="article-date">
  	<time datetime="2019-09-10T10:56:32.958Z" itemprop="datePublished">2019-09-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/10/hello-world/">
        Hello World
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2019 陈文才
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>